#1 Write a query to identify the top 2 Power Users who sent the highest number of messages on Microsoft Teams in August 2022. Display the IDs of these 2 users along with the total number of messages they sent. Output the results in descending order based on the count of the messages.

Assumption:

No two users have sent the same number of messages in August 2022.

SELECT sender_id, count(*) as message_count
from messages
where date_trunc('month', sent_date) = '2022-08-01'
group by sender_id
order by message_count DESC
limit 2;

#2 Assume you're given a table containing job postings from various companies on the LinkedIn platform. Write a query to retrieve the count of companies that have posted duplicate job listings.

Definition:

Duplicate job listings are defined as two job listings within the same company that share identical titles and descriptions.

with job_cnt AS(
select company_id, title, description, count(job_id) as cnt from job_listings
group by 1,2,3)

select count(company_id)
from job_cnt
where cnt >1;

#3. Assume you're given two tables containing data about Facebook Pages and their respective likes (as in "Like a Facebook Page").

Write a query to return the IDs of the Facebook pages that have zero likes. The output should be sorted in ascending order based on the page IDs.
SELECT p.page_id 
from pages  p
left join page_likes l
on p.page_id = l.page_id
where l.page_id is null
order by ppage_id;

SELECT page_id
FROM pages
WHERE NOT EXISTS (
  SELECT page_id
  FROM page_likes AS likes
  WHERE likes.page_id = pages.page_id
)
order by page_id;

SELECT page_id
FROM pages
EXCEPT
SELECT page_id
FROM page_likes
order by page_id;

#4. Assume you're given the table on user viewership categorised by device type where the three types are laptop, tablet, and phone.

Write a query that calculates the total viewership for laptops and mobile devices where mobile is defined as the sum of tablet and phone viewership. Output the total viewership for laptops as laptop_reviews and the total viewership for mobile devices as mobile_views.
SELECT 
count(case when device_type ='laptop' then 1 end) as laptop_reviews,
count(case when device_type in ('tablet', 'phone') then 1 end) as mobile_views
FROM viewership;
SELECT 
  SUM(CASE WHEN device_type = 'laptop' THEN 1 ELSE 0 END) AS laptop_views, 
  SUM(CASE WHEN device_type IN ('tablet', 'phone') THEN 1 ELSE 0 END) AS mobile_views 
FROM viewership;
SELECT 
  COUNT(*) FILTER (WHERE device_type = 'laptop') AS laptop_views,
  COUNT(*) FILTER (WHERE device_type IN ('tablet', 'phone'))  AS mobile_views 
FROM viewership;

#5. Given a table of Facebook posts, for each user who posted at least twice in 2021, write a query to find the number of days between each userâ€™s first post of the year and last post of the year in the year 2021. Output the user and number of the days between each user's first and last post.

SELECT 
	user_id, 
    MAX(post_date::DATE) - MIN(post_date::DATE) AS days_between --extract(day from max(post_date::timestamp) - min(post_date::timestamp)) as days_between
FROM posts
WHERE DATE_PART('year', post_date::DATE) = 2021 
GROUP BY user_id
HAVING COUNT(post_id)>1;

#6. ou're provided with two tables: the advertiser table contains information about advertisers and their respective payment status, and the daily_pay table contains the current payment information for advertisers, and it only includes advertisers who have made payments.

Write a query to update the payment status of Facebook advertisers based on the information in the daily_pay table. The output should include the user ID and their current payment status, sorted by the user id.

The payment status of advertisers can be classified into the following categories:

New: Advertisers who are newly registered and have made their first payment.
Existing: Advertisers who have made payments in the past and have recently made a current payment.
Churn: Advertisers who have made payments in the past but have not made any recent payment.
Resurrect: Advertisers who have not made a recent payment but may have made a previous payment and have made a payment again recently.
Before proceeding with the question, it is important to understand the possible transitions in the advertiser's status based on the payment status. The following table provides a summary of these transitions:
"Current Status" column: Represents the advertiser's current status.
"Payment Status" column: Represents the updated payment status based on the conditions
"Payment on Day T" column: Indicates whether the advertiser made a payment on a specific day (T) or not.
The transitions between payment statuses in the provided table can be summarized as follows:

Rows 2, 4, 6, and 8: If an advertiser does not make a payment on day T, regardless of their previous status, their payment status transitions to "CHURN" as the updated status.
Rows 1, 3, 5, and 7: If an advertiser makes a payment on day T, the status is updated to either "EXISTING" or "RESURRECT" based on their previous status. If the previous status was "CHURN," the updated status is "RESURRECT." For any other previous status, the updated status is "EXISTING."
SELECT coalesce(a.user_id, p.user_id) as user_id,
case when paid is null then 'CHURN'
     when paid is not null and status ='CHURN' then 'RESURRECT'
     when paid is not null and status in ('NEW', 'EXISTING','RESURRECT') then 'EXISTING'
     when paid is not null and status is null then 'NEW'
     end as new_status
from advertiser a
full join daily_pay p
on a.user_id = p.user_id
order by user_id;
